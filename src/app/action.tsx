'use server';

import '@total-typescript/ts-reset';

import { fetchWeatherApi } from 'openmeteo';
import { OpenAI } from 'openai';
import { createAI, getMutableAIState, render } from 'ai/rsc';
import z from 'zod';
import { AiTextToImageInput } from '@cloudflare/ai/dist/tasks/text-to-image';
import { Ai } from '@cloudflare/ai';
import { getRequestContext } from '@cloudflare/next-on-pages';
import { SignInButton, SignedIn, SignedOut, UserButton, auth, clerkClient } from '@clerk/nextjs';
import { Message } from '@/components/messages';
import Markdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { uploadThing } from '@/upload-thing';

const getRateLimit = async (identifier: string, limit = 1_000, period = '1d') => {
  const namespace = '076021b1-3a73-45b3-8c6e-1a3d19654708'; // rlimit.com namespace ID
  const response = await fetch(`https://rlimit.com/${namespace}/${limit}/${period}/${identifier}`);
  const body = await response.json<{
    ok: boolean;
    remaining: number;
  }>();

  return {
    isLimited: body.remaining <= 0,
    remaining: body.remaining,
  };
};

type ImagesProps = {
  images: string[];
  prompt: string;
  timeTaken: number;
};

// How much time this took
const humanTime = (time: number) => {
  if (time < 0) return '0ms';
  if (time < 1_000) return `${time}ms`;
  if (time < 60_000) return `${(time / 1_000).toFixed(2)}s`;
  if (time < 3_600_000) return `${(time / 60_000).toFixed(2)}m`;
  return `${(time / 3_600_000).toFixed(2)}h`;
};

const Images = ({ images, prompt, timeTaken }: ImagesProps) => {
  return (
    <div className="flex flex-col gap-2">
      <div className="flex flex-row gap-2 flex-wrap overflow-x-scroll w-full">
        {/* The images generated by the prompt */}
        {images.map((image, index) => (
          // eslint-disable-next-line @next/next/no-img-element
          <img key={index} src={image} alt={prompt} className="size-56" />
        ))}
      </div>

      {/* Prompt */}
      <div>
        Generated {images.length} image{images.length !== 1 && 's'} in {humanTime(timeTaken)} using the prompt &quot;{prompt}
        &quot;
      </div>
    </div>
  );
};

async function* raceAll<Output>(input: Promise<Output>[]) {
  const promises = input.map(
    (p) =>
      (p = p.then((val) => {
        promises.splice(promises.indexOf(p), 1);
        return val;
      })),
  );

  while (promises.length) yield Promise.race(promises);
}

const getTimeToRateLimitReset = () => {
  const midnightTonight = new Date();
  midnightTonight.setHours(24, 0, 0, 0);
  return humanTime(midnightTonight.getTime() - Date.now());
};

export const submitUserMessage = async (userInput: string): Promise<Message> => {
  'use server';

  // If the user isn't authenticated, return the login prompt
  const { userId } = auth();

  if (!userId) {
    return {
      id: Date.now(),
      role: 'system',
      content: <SignInButton>Click here to signin</SignInButton>,
    };
  }

  // User has reached their limit
  const rateLimit = await getRateLimit(userId);
  if (rateLimit.isLimited) {
    return {
      id: Date.now(),
      role: 'system',
      content: `You are currently rate limited. Your limit will reset in ${getTimeToRateLimitReset}.`,
    };
  }

  try {
    const aiState = getMutableAIState<typeof AI>();

    // Update AI state with new message.
    aiState.update([
      ...aiState.get(),
      {
        role: 'user',
        content: userInput,
      },
    ]);

    // Get the last 50 messages
    const previousMessages = aiState.get();
    const previousFityMessages = previousMessages.slice(-50);

    // render() returns a stream of UI components
    const ui = render({
      model: 'gpt-4-turbo-preview',
      provider: openai,
      messages: [
        {
          role: 'system',
          content:
            'You are an assistant, if you dont know what the user asked or get confused reply with something sassy.' +
            'When generating an image you should add extra words to make them look nicer, think about the camera, lighting, and the subject of the image.',
        },
        ...previousFityMessages.map((message) => ({
          role: message.role === 'user' ? ('user' as const) : ('assistant' as const),
          content: message.content,
        })),
      ],
      initial: <div>hmmm...</div>,
      // `text` is called when an AI returns a text response (as opposed to a tool call)
      text: ({ content, done }) => {
        // text can be streamed from the LLM, but we only want to close the stream with .done() when its completed.
        // done() marks the state as available for the client to access
        if (done) {
          console.info('replying with text');

          aiState.done([
            ...aiState.get(),
            {
              role: 'assistant',
              content,
            },
          ]);
        }

        return (
          <Markdown
            components={{
              code(props) {
                const { children, className, node, ...rest } = props;
                const match = /language-(\w+)/.exec(className || '');
                return match ? (
                  // @ts-expect-error
                  <SyntaxHighlighter {...rest} PreTag="div" language={match[1]} style={oneDark}>
                    {String(children).replace(/\n$/, '')}
                  </SyntaxHighlighter>
                ) : (
                  <code {...rest} className={className}>
                    {children}
                  </code>
                );
              },
            }}
          >
            {content}
          </Markdown>
        );
      },
      tools: {
        create_image: {
          description: 'Create an image',
          parameters: z
            .object({
              prompt: z.string().describe('the prompt to generate the image from'),
              number_of_images: z.number().min(1).max(50).default(1).describe('the number of images to generate'),
            })
            .required(),
          render: async function* (_props) {
            console.info('replying with create_image', {
              props: _props,
            });
            // I really have no fucking idea why this is needed but if i dont do it we get undefined
            const props = JSON.parse(JSON.parse(JSON.stringify(_props)) as string) as typeof _props;
            const prompt = props.prompt;
            const number_of_images = Math.min(50, props.number_of_images ?? 1);

            yield (
              <div>{`Generating ${
                number_of_images === 1 ? 'image' : `${number_of_images} images`
              } using prompt "${prompt}"...`}</div>
            );

            const urls: string[] = [];

            try {
              console.info('generating images', {
                prompt,
                number_of_images,
              });
              const startTime = Date.now();

              for await (const image of raceAll(
                Array.from({ length: number_of_images }, () => createImage(userId, prompt)),
              )) {
                urls.push(image);

                yield <Images prompt={prompt} images={urls} timeTaken={Date.now() - startTime} />;
              }

              console.info('Saving images', {
                prompt,
                urls,
              });

              const { env } = getRequestContext();
              const imageId = crypto.randomUUID();
              const data = {
                urls,
                prompt,
                number_of_images,
                timeTaken: Date.now() - startTime,
                createdAt: new Date().toISOString(),
              };

              // Save the entry to the user's database
              await env.KV.put(`images:${userId}:${imageId}`, JSON.stringify(data));

              console.info('Saved image', {
                prompt,
                urls,
                imageId,
              });

              const timeTaken = Date.now() - startTime;

              console.info('generated images', {
                prompt,
                number_of_images,
                timeTaken,
              });

              aiState.done([
                ...aiState.get(),
                {
                  role: 'function',
                  name: 'create_image',
                  content: JSON.stringify({
                    prompt,
                  }),
                },
              ]);

              return <Images prompt={prompt} images={urls} timeTaken={timeTaken} />;
            } catch (error) {
              console.error('Failed generating images', {
                error,
              });
              if (error instanceof Error) {
                return (
                  <pre>
                    {JSON.stringify(
                      {
                        message: error.message,
                        stack: error.stack,
                        cause: error.cause,
                      },
                      null,
                      2,
                    )}
                  </pre>
                );
              }

              return <div>Unknown error</div>;
            }
          },
        },
        ratelimit: {
          description: "Get details about the user's rate limit",
          parameters: z.object({}).required(),
          render: async function () {
            const rateLimit = await getRateLimit(userId);

            aiState.done([
              ...aiState.get(),
              {
                role: 'function',
                name: 'ratelimit',
                content: JSON.stringify(rateLimit),
              },
            ]);

            // If the user is rate limited, tell them
            if (rateLimit.isLimited)
              return <div>You are currently rate limited, this limit resets in {getTimeToRateLimitReset()}</div>;

            // If the user isn't rate limited, return the remaining requests
            return (
              <div>
                You have {rateLimit.remaining} requests remaining, this limit resets in {getTimeToRateLimitReset()}
              </div>
            );
          },
        },
        describe_image: {
          description: 'Describe an image',
          parameters: z
            .object({
              image_url: z.string().describe('the image to describe'),
            })
            .required(),
          render: async function* (_props) {
            yield <Loading />;

            const props = JSON.parse(JSON.parse(JSON.stringify(_props)) as string) as typeof _props;
            const { image_url } = props;

            // Fetch the image
            const { env } = getRequestContext();
            const ai = new Ai(env.AI);

            console.info('Fetching image', {
              image_url,
            });

            const image = await fetch(image_url)
              .then((res) => res.arrayBuffer())
              .then((buffer) => Array.from(new Uint8Array(buffer)));

            console.info('Fetched image', {
              image_url,
            });

            console.info('Describing image', {
              image_url,
            });

            const response = (await ai.run('@cf/unum/uform-gen2-qwen-500m', {
              image,
              prompt: 'Describe the image',
            })) as {
              description: string;
            };

            console.info('Described image', {
              image_url,
              response,
            });

            return <div>{response.description}</div>;
          },
        },
        user_count: {
          description: 'Get the number of users in the system',
          parameters: z.object({}).required(),
          render: async function* () {
            yield <Loading />;
            const totalUsers = await clerkClient.users.getCount();

            aiState.done([
              ...aiState.get(),
              {
                role: 'function',
                name: 'user_count',
                content: JSON.stringify(totalUsers),
              },
            ]);

            return <div>There are {totalUsers} users in the system</div>;
          },
        },
        get_images: {
          description: 'Get the previous images generated by the user',
          parameters: z.object({}).required(),
          render: async function* () {
            yield <Loading />;

            const { env } = getRequestContext();
            const files = await env.KV.list({ prefix: `images:${userId}` });
            const imageSets = await Promise.all(
              files.keys.map(async (key) => {
                const image = await env.KV.get<string>(key.name);
                return image
                  ? (JSON.parse(image) as {
                      urls: string[];
                      prompt: string;
                      number_of_images: number;
                      timeTaken: number;
                      createdAt: string;
                    })
                  : null;
              }),
            ).then((images) => images.filter(Boolean));

            if (imageSets.length === 0) {
              return <div>No images found</div>;
            }

            return (
              <div>
                <h2>Previous images</h2>
                <div>
                  {imageSets
                    .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())
                    .map((imageSet, index) => (
                      <div key={index}>
                        <h3>{imageSet.prompt}</h3>
                        <Images prompt={imageSet.prompt} images={imageSet.urls} timeTaken={imageSet.timeTaken} />
                      </div>
                    ))}
                </div>
              </div>
            );
          },
        },
        get_weather_info: {
          description: 'Get the weather information for the user',
          parameters: z
            .object({
              location: z.string().describe('the location to get the weather for'),
              latitude: z.number().describe('the latitude of the location'),
              longitude: z.number().describe('the longitude of the location'),
            })
            .required(),
          render: async function* (_props) {
            yield <Loading />;

            const props = JSON.parse(JSON.parse(JSON.stringify(_props)) as string) as typeof _props;
            const weatherInfo = await fetchWeatherData(props);

            aiState.done([
              ...aiState.get(),
              {
                role: 'function',
                name: 'get_weather_info',
                content: JSON.stringify(weatherInfo),
              },
            ]);

            return <div>{weatherInfo}</div>;
          },
        },
        // get_flight_info: {
        //   description: 'Get the information for a flight',
        //   parameters: z
        //     .object({
        //       flightNumber: z.string().describe('the number of the flight'),
        //     })
        //     .required(),
        //   // flightNumber is inferred from the parameters passed above
        //   render: async function* ({ flightNumber }) {
        //     console.info('replying with get_flight_info');
        //     yield <Loading />;
        //     const flightInfo = await getFlightInfo(flightNumber);

        //     aiState.done([
        //       ...aiState.get(),
        //       {
        //         role: 'function',
        //         name: 'get_flight_info',
        //         // Content can be any string to provide context to the LLM in the rest of the conversation
        //         content: JSON.stringify(flightInfo),
        //       },
        //     ]);

        //     return <FlightCard flightInfo={flightInfo} />;
        //   },
        // },
      },
    });

    return {
      id: Date.now(),
      role: 'system',
      content: ui,
    };
  } catch (error: unknown) {
    if (!(error instanceof Error)) {
      throw new Error('Unknown error');
    }

    console.error('An error occurred', {
      error,
    });

    return {
      id: Date.now(),
      role: 'system',
      content: `An error occurred: ${error.message}`,
    };
  }
};

const actions = {
  submitUserMessage,
} as const;

const initialAIState: {
  role: 'user' | 'assistant' | 'system' | 'function';
  content: string;
  id?: string;
  name?: string;
}[] = [];

const initialUIState: Message[] = [];

export type Actions = typeof actions;

// AI is a provider you wrap your application with so you can access AI and UI state in your components.
export const AI = createAI({
  actions,
  // Each state can be any shape of object, but for chat applications
  // it makes sense to have an array of messages. Or you may prefer something like { id: number, messages: Message[] }
  initialUIState,
  initialAIState,
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  baseURL: 'https://gateway.ai.cloudflare.com/v1/14009bd6d1f402745354fa38a17ef6aa/test/openai',
});

const Loading = () => <div>Loading...</div>;

const retryPromise = async <T,>(promise: () => Promise<T>, retries = 3) => {
  let error: unknown;

  for (let i = 0; i < retries; i++) {
    try {
      return await promise();
    } catch (e: unknown) {
      error = e;
    }
  }

  throw error;
};

const generateFileName = (prompt: string) => prompt.toLowerCase().replace(/[^a-z0-9]/g, '_');

const createImage = async (userId: string, prompt: string) => {
  // Fetch the image
  const { env } = getRequestContext();
  const ai = new Ai(env.AI);

  const inputs = {
    prompt,
    num_steps: 10,
  } satisfies AiTextToImageInput;

  console.info('Fetching image', {
    prompt,
  });

  // Fetch the image
  const response = await retryPromise(
    async () => ai.run('@cf/stabilityai/stable-diffusion-xl-base-1.0', inputs) as Promise<Uint8Array>,
    3,
  );

  console.info('Fetched image', {
    prompt,
  });

  const file = new File([new Blob([response])], generateFileName(prompt));

  console.info('Uploading image', {
    prompt,
    fileSize: file.size,
    fileName: file.name,
  });

  // Upload the image to upload thing
  const uploadedFileResponse = await uploadThing.uploadFiles(file);

  // Check if the upload failed
  if (uploadedFileResponse.error) {
    console.error('Failed uploading image', {
      error: uploadedFileResponse.error,
    });
    throw new Error('Failed uploading image');
  }

  console.info('Uploaded image', {
    prompt,
    url: uploadedFileResponse.data?.url,
  });

  // Return the image URL
  return uploadedFileResponse.data?.url;
};

const fetchWeatherData = async (params: { latitude: number; longitude: number; location: string }) => {
  const url = 'https://api.open-meteo.com/v1/forecast';
  const responses = await fetchWeatherApi(url, {
    latitude: params.latitude,
    longitude: params.longitude,
    hourly: 'temperature_2m',
  });

  // Helper function to form time ranges
  const range = (start: number, stop: number, step: number) =>
    Array.from({ length: (stop - start) / step }, (_, i) => start + i * step);

  // Process first location. Add a for-loop for multiple locations or weather models
  const response = responses[0];

  // Attributes for timezone and location
  const utcOffsetSeconds = response.utcOffsetSeconds();
  const timezone = response.timezone();
  const timezoneAbbreviation = response.timezoneAbbreviation();
  const latitude = response.latitude();
  const longitude = response.longitude();

  const hourly = response.hourly()!;

  // Note: The order of weather variables in the URL query and the indices below need to match!
  const weatherData = {
    hourly: {
      time: range(Number(hourly.time()), Number(hourly.timeEnd()), hourly.interval()).map(
        (t) => new Date((t + utcOffsetSeconds) * 1000),
      ),
      temperature2m: hourly.variables(0)!.valuesArray()!,
    },
  };

  // Get the current time at hour mark
  const now = new Date();
  now.setHours(now.getHours(), 0, 0, 0);

  // Find the current temperature
  const currentTempIndex = weatherData.hourly.time.findIndex((time) => {
    const hourTime = new Date(time);
    hourTime.setHours(hourTime.getHours(), 0, 0, 0);
    return hourTime.getTime() === now.getTime();
  });
  const currentTemp = weatherData.hourly.temperature2m[currentTempIndex];
  const temps = Array.from(weatherData.hourly.temperature2m);

  // Min and max temperature
  const minTemp = Math.min(...temps);
  const maxTemp = Math.max(...temps);

  return `It is currently ${currentTemp.toFixed(0)}°C in ${params.location} with a high of ${maxTemp.toFixed(
    0,
  )}°C and a low of ${minTemp.toFixed(0)}°C`;
};
